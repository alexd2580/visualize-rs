#version 450

layout(local_size_x = 8, local_size_y = 8) in;

layout(push_constant, std140) uniform PushConstants {
    layout(offset = 0) uint frame_index;
    layout(offset = 4) float time;

    layout(offset = 8) float bass_energy;
    layout(offset = 12) bool is_beat;
    layout(offset = 16) uint real_beats;

    layout(offset = 20) float bpm_confidence;
    layout(offset = 24) float bpm_period;
    layout(offset = 28) int quarter_beat_index;
    layout(offset = 32) float beat_fract;
} constants;

layout(rgba32f, binding = 0) uniform image2D canvas;

layout(binding = 1) buffer Dft {
    int size;
    float data[];
} signal_dft;

vec2 ndc_to_tex(vec2 ndc) {
    return 0.5 * ndc + 0.5;
}

float len2(vec2 v) {
    return v.x * v.x + v.y * v.y;
}

vec3 neon_color(float time) {
    float h = fract(time);
    float s = 1.0;
    float v = 1.0;

    float r = abs(h * 6.0 - 3.0) - 1.0;
    float g = 2.0 - abs(h * 6.0 - 2.0);
    float b = 2.0 - abs(h * 6.0 - 4.0);
    return clamp(vec3(r, g, b), 0.0, 1.0);
}

float grid(vec2 xy, ivec2 size, ivec2 pos) {
    vec2 cell_size = 2.0 / vec2(size);
    vec2 center = (vec2(pos) + 0.5) * cell_size - 1.0;

    vec2 d = abs(xy - center) - 0.45 * cell_size;
    float sdf = length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);

    return clamp(ceil(-sdf), 0.0, 1.0);
}

// float spinner(vec2 xy, float pct) {
// float sdArc( in vec2 p, in vec2 sc, in float ra, float rb )
// {
//     // sc is the sin/cos of the arc's aperture
//     p.x = abs(p.x);
//     return ((sc.y*p.x>sc.x*p.y) ? length(p-sc*ra) :
//                                   abs(length(p)-ra)) - rb;
// }
// }

float circle(vec2 xy, vec2 pos, float radius) {
    return float((len2(xy - pos) + 0.0001) < radius * radius);
}

vec3 quad_grid(vec2 xy) {
    int i = constants.quarter_beat_index & 3;
    return grid(xy, ivec2(4, 5), ivec2(i, 0)) * vec3(0.22, 1.0, 0.07);
}

vec3 beat_grid(vec2 xy) {
    int i = (constants.quarter_beat_index & 12) >> 2;
    return grid(xy, ivec2(4, 5), ivec2(i, 4)) * vec3(1.0, 0.35, 0.0);
}

vec3 bar_grid(vec2 xy) {
    int i = (constants.quarter_beat_index & 112) >> 4;
    return grid(xy, ivec2(8, 10), ivec2(i, 9)) * vec3(0.0, 0.72, 1.0);
}

vec3 dft(vec2 xy) {
    vec2 tex = ndc_to_tex(xy * 2.0);
    float x = tex.x - 0.5;

    float dft_index_f = pow(x, 2) * signal_dft.size;
    int dft_index = int(dft_index_f);

    if (abs(x) > 1.0) {
        return vec3(0.0);
    }

    if (abs(x) < 0.01) {
        return vec3(0.0, 0.0, 1.0);
    }

    if (abs(x - 1.0) < 0.01) {
        return vec3(1.0, 0.0, 0.0);
    }

    if (abs(x + 1.0) < 0.01) {
        return vec3(0.0, 1.0, 0.0);
    }

    float inv_y = abs(0.5 - tex.y);
    if (abs(inv_y) < 0.01) {
        return vec3(0.0, 0.0, 1.0);
    }

    if (abs(inv_y - 1.0) < 0.01) {
        return vec3(1.0, 0.0, 0.0);
    }

    if (abs(inv_y + 1.0) < 0.01) {
        return vec3(0.0, 1.0, 0.0);
    }

    float min_db = -20.0;
    float db_range = 120.0;
    float db = (signal_dft.data[dft_index] - min_db) / db_range;

    vec3 value = db > inv_y ? neon_color(db + sin(0.001 * constants.time * inv_y)) : vec3(0.0);

    return vec3(value);
}

void main() {

    ivec2 ipixel_coords = ivec2(gl_GlobalInvocationID.xy);
    ivec2 iimage_size = ivec2(gl_NumWorkGroups.xy * gl_WorkGroupSize.xy);

    vec2 pixel_coords = vec2(ipixel_coords) + 0.5;
    vec2 ndc = 2 * pixel_coords / vec2(iimage_size) - 1;

    float average_size = 0.5 * float(iimage_size.x + iimage_size.y);
    vec2 ndc_aspect = vec2(iimage_size) * ndc / average_size;

    // Circle in center.
    float bass_pump_color_index = 0.25 * constants.time / constants.bpm_period;
    vec3 bass_pump_color = neon_color(bass_pump_color_index);
    float radius = 1.5 * constants.bass_energy + 0.1;
    vec3 bass_pump = circle(ndc_aspect, vec2(0.0), radius) * bass_pump_color;

    // Ticker displays.
    vec3 beat_display = quad_grid(ndc_aspect * 1.5) + beat_grid(ndc_aspect * 1.5) + bar_grid(ndc_aspect * 1.5);

    // DFT
    vec3 dft_color = dft(ndc_aspect * 1.5);

    // Current image.
    vec3 color = bass_pump + beat_display * pow(constants.bpm_confidence, 2.0);
    color = dft_color;


    // float beat_index = float(constants.real_beats);
    // vec2 shifted_pixel_coords = pixel_coords + 10.0 * vec2(
    //     sin(beat_index), // + 0.293847987435 * constants.time),
    //     cos(beat_index) // + 0.234567438598 * constants.time)
    // );
    // shifted_pixel_coords = pixel_coords - vec2(0.0, +10.0);
    //
    // // Overlayed on top of previous canvas.
    // vec3 load_color = 0.9 * imageLoad(canvas, ivec2(shifted_pixel_coords)).rgb;
    // imageStore(canvas, ipixel_coords, vec4(0.9 * load_color + color, 1));
    imageStore(canvas, ipixel_coords, vec4(color, 1));
}
