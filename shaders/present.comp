#version 450

layout(local_size_x = 8, local_size_y = 8) in;

layout(push_constant, std140) uniform PushConstants {
    layout(offset = 0) uint frame_index;
    layout(offset = 4) float time;

    layout(offset = 8) float bass_energy;
    layout(offset = 12) bool is_beat;
    layout(offset = 16) uint real_beats;

    layout(offset = 20) float bpm_confidence;
    layout(offset = 24) float bpm_period;
    layout(offset = 28) int beat_index;
    layout(offset = 32) float beat_fract;
} constants;

layout(binding = 0) uniform sampler2D canvas;
layout(rgba32f, binding = 1) uniform image2D frame;
// layout(rgba32f, binding = 2) uniform image2D frame_prev;
layout(binding = 2) uniform sampler2D frame_prev;
layout(rgba32f, binding = 3) uniform image2D present;

vec2 ndc_to_tex(vec2 ndc) {
    return 0.5 * ndc + 0.5;
}

vec2 tex_to_ndc(vec2 tex) {
    return 2.0 * tex - 1.0;
}

vec2 pixel_to_tex(ivec2 pixel, ivec2 size) {
    // +0.5 because querying the texture using sampler we get floating pixel coordinates.
    return (vec2(pixel) + 0.5) / vec2(size);
}

vec2 pixel_to_ndc(ivec2 pixel, ivec2 size) {
    return tex_to_ndc(pixel_to_tex(pixel, size));
}

mat2 rotation_2d(float angle) {
    float c = cos(angle);
    float s = sin(angle);
    return mat2(
        c, -s,
        s,  c
    );
}

vec3 load_canvas(vec2 ndc, out float mask) {
    // Overlayed on top of previous canvas.
    mat2 rotate_canvas = rotation_2d(sin(constants.time) * constants.bass_energy);
    vec2 rotated = rotate_canvas * ndc;
    vec2 scale = 1.0 - vec2(constants.bass_energy);
    vec2 canvas_coords = rotated * scale;

    vec3 canvas_color = texture(canvas, ndc_to_tex(canvas_coords)).rgb;
    vec3 canvas_color_b = texture(canvas, ndc_to_tex(vec2(0.9, 0.8) * canvas_coords)).rgb;

    mask = min(dot(canvas_color_b, canvas_color_b), 1.0);
    return canvas_color;
}

vec3 load_prev_frame(vec2 ndc) {
    float bar = float(constants.beat_index >> 2);
    vec2 flight_direction = vec2(
        sin(bar + 0.293847987435 * constants.time),
        cos(bar + 0.234567438598 * constants.time)
    );
    vec2 zoom = 1.0 + 0.01 * vec2(
        sin(0.293847987435 * constants.time),
        cos(0.234567438598 * constants.time)
    );
    vec2 prev_coords = zoom * ndc + 0.01 * flight_direction;
    vec3 prev_color = texture(frame_prev, ndc_to_tex(prev_coords)).rgb; // prev_coords

    return prev_color;
}

void main() {
    ivec2 ipixel_coords = ivec2(gl_GlobalInvocationID.xy);
    ivec2 iimage_size = ivec2(gl_NumWorkGroups.xy * gl_WorkGroupSize.xy);

    vec2 pixel_coords = vec2(ipixel_coords) + 0.0;
    vec2 ndc = 2.0 * pixel_coords / vec2(iimage_size) - 1.0;

    float canvas_mask;
    vec3 canvas_color = load_canvas(ndc, canvas_mask);
    vec3 frame_color = load_prev_frame(ndc);


    vec3 next_frame = canvas_color + 0.98 * frame_color;
    vec3 next_present = (1.0 - canvas_mask) * frame_color + canvas_color;

    // vec3 sum_color = len_canvas > 0.001 ? (len_canvas > 0.5 ? canvas_color_larger : vec3(0)) : 0.99 * prev_color;
    // vec3 sum_color2 = len_canvas > 0.5 ? canvas_color : 0.99 * prev_color;

    imageStore(frame, ipixel_coords, vec4(next_frame, 1));
    imageStore(present, ipixel_coords, vec4(next_present, 1));


    // vec3 add_color = fract(constants.frame_index * 0.1203948230 * vec3(float(ipixel_coords.x) / iimage_size.x, float(ipixel_coords.y) / iimage_size.y, 0));
    //
    // if (constants.frame_index % 60 < 60) {
    //     imageStore(present, ipixel_coords, vec4(add_color, 1));
    // } else {
    //     imageStore(present, ipixel_coords, vec4(load_color, 1));
    // }
}
